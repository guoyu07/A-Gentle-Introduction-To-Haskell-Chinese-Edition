2.值，类型及其他玩意儿
**************************

值和类型
----------

Haskell是一门\ **纯粹的函数式编程语言**\ (purely functional language)，因此，所有计算都是通过对表达式(expression)进行求值来完成的。

每个值都有相应的类型，比如说，对于\ **原子型值**\ (atomic values)，有数字值(integer)\ ``5``\ ，字符值(character)\ ``'a'``\ ，以及函数(function)\ ``x -> x+1``\ ，等等；而对于\ **结构型值**\ (structured values)，则有列表(list)如\ ``[1, 2, 3]``\ ，或点对(pair)\ ``('b', 4)``\ ，等等。

正如表达式定义了值一样，类型表达式(type expression)也定义了类型值(type value)，或者简单点说，类型表达式定义了类型(type)。

以下是一些类型表达式的例子：对于原子型值，有\ ``Integer``\ 类型，表示无限精度(infinite-precision)的数字值；\ ``Char``\ 类型，表示字符值；\ ``Integer->Integer``\ ，表示函数从\ ``Integer``\ 类型映射(mapping)到\ ``Integer``\ 类型，等等。

而对于结构型值，则有\ ``[Integer]``\ 类型，表示一个只包含数字值的列表；以及\ ``(Char,Integer)``\ 类型，表示一个由字符值和数字值组成的点对；等等。

在Haskell中，所有的值都是\ **第一类的**\ (first-class)——它们可以作为参数被传入到函数，作为计算结果而被返回，或是放置在(placed in)数据结构中，诸如此类。

另一方面，Haskell的类型，\ *不*\ 是第一类的。


类型指派
---------

类型可以在某种程度上描述值，而为值关联相应的类型称之为\ **类型指派**\ (typing)。

用我们之前举过的类型和值为例，以下是一些类型指派的例子：

::

    5         :: Integer
    'a'       :: Char
    inc       :: Integer -> Integer
    [1, 2, 3] :: [Integer]
    ('b', 4)  :: (Char, Integer)

其中\ ``::``\ 符号可以读作“值。。。的类型是。。。”，比如，我们可以将\ ``5 :: Integer``\ 读作“值\ ``5``\ 的类型是\ ``Integer``\ ”，或者，再简单点，直接说：“数字值5”。


函数定义
-------------

在Haskell中，函数一般通过一系列\ **方程**\ (equation)来定义(define)。

比如函数\ ``inc``\ 可以用以下这条方程来定义：

::

    inc n = n+1

其中，方程是\ **声明**\ (declaration)的首个例子，另一种声明称之为\ **类型签名声明**\ (\ `§4.4.1 <http://www.haskell.org/onlinereport/decls.html#type-signatures>`_\ )(type signature declaration)，可以用于对函数进行显式的类型指派。

比如说，我们可以使用类型签名声明，为\ ``inc``\ 函数指派类型\ ``Integer -> Integer``\ ：

::

    inc :: Integer -> Integer
    inc n = n+1

我们将在第三章中介绍函数定义。


求值
-----

当我们希望在数学上表示对一个表达式\ :math:`e_1`\ 求值，从而得到另一个表达式(或值)\ :math:`e_2`\ 的时候，我们会使用符号：

:math:`e_1 \Rightarrow e_2`

比如，像这样：

::

    inc (inc 3) => 5

静态类型系统
--------------

Haskell的\ **静态类型系统**\ (static type system)定义了类型和值之间的形式关系(\ `§4.1.4 <http://www.haskell.org/onlinereport/decls.html#type-semantics>`_\ (formal relation)，它确保Haskell程序都是\ **类型安全**\ (type safe)的，也即是说，Haskell程序不会遇上\ **类型不匹配**\ (mismatch type)的问题。

举个例子，我们不能对两个字符串进行加法操作，因为表达式\ ``'a'+'b'``\ 是\ **类型不合法**\ (ill-type)的。

众所周知，静态类型的主要好处是可以在编译期间(compile-time)发现类型错误，帮助用户理解程序，并生成更高效的执行码。

当然，类型系统不能发现所有的错误，比如表达式\ ``1/0``\ 就是\ **类型合法**\ (typable)的，但执行这个表达式却会引发一个错误。

另一方面，类型系统还必须保证用户显式指派的类型的正确性。而实际上，除少数几种状况之外，强大的Haskell允许我们省略一切类型签名，类型系统能为我们\ **推导**\ (infer)出正确的类型。

尽管如此，对像是\ ``inc``\ 那样的函数使用类型签名也没什么坏处，毕竟除了指定类型之外，类型签名还有文档化和增强可读性的作用。

.. note:: 

    请注意，我们对类型标识符使用了首字母大写的形式，像是\ ``Integer``\ 或\ ``Char``\ ，但对于值，则使用了小写形式，如\ ``inc``\ 。
    
    这不仅仅是一个约定俗成的规矩那么简单，而是Haskell语法所强制要求的。

    实际上，Haskell中的标识符是区分大小写的，\ ``foo``\ 、\ ``fOo``\ 或\ ``fOO``\ 代表完全不同的标识符。
